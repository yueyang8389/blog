(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{307:function(a,r,t){"use strict";t.r(r);var e=t(3),v=Object(e.a)({},function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"判断array的方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判断array的方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 判断Array的方法")]),a._v(" "),t("ul",[t("li",[a._v("[].instanceof Array")]),a._v(" "),t("li",[a._v("Object.prototype.toString.call([])")]),a._v(" "),t("li",[a._v("Array.isArray([])")]),a._v(" "),t("li",[a._v("[].constructor === Array")])]),a._v(" "),t("p",[t("code",[a._v("instanceof")]),a._v("无法判断基本数据类型"),t("br"),a._v(" "),t("code",[a._v("Object.prototype.toString")]),a._v("直接使用，会返回都是内容的字符串.需要使用call或者apply方法来改变toString方法的执行上下文"),t("br"),a._v(" "),t("code",[a._v("Array.isArray")]),a._v("es6新提供的方法，需要做polyfill，向下兼容")]),a._v(" "),t("h2",{attrs:{id:"数组最大值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组最大值","aria-hidden":"true"}},[a._v("#")]),a._v(" 数组最大值")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("Math.max(1,22,5,19)"),t("br"),a._v("\n利用apply得出数组的最大值，Math.max.apply(Math,[1,22,5,19])")])]),a._v(" "),t("li",[t("p",[a._v("利用数组sort方法"),t("br"),a._v("\n[1,22,5,19].sort((a,b)=> (b-a))  "),t("code",[a._v("a-b")]),a._v(" 从小到大，"),t("code",[a._v("b-a")]),a._v("从大到小")])]),a._v(" "),t("li",[t("p",[a._v("利用拓展运算符"),t("br"),a._v("\nMath.max(...[1,22,5,19])")])])]),a._v(" "),t("h2",{attrs:{id:"构造函数与普通函数的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造函数与普通函数的区别","aria-hidden":"true"}},[a._v("#")]),a._v(" 构造函数与普通函数的区别")]),a._v(" "),t("p",[a._v("构造函数与其他函数的唯一区别，就在于调用它们的方式不同，任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数;而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样")]),a._v(" "),t("p",[a._v("使用构造函数的主要问题，就是每个方法都要在每个 实例上重新创建一遍")]),a._v(" "),t("h2",{attrs:{id:"参考链接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考链接","aria-hidden":"true"}},[a._v("#")]),a._v(" 参考链接")])])},[],!1,null,null,null);r.default=v.exports}}]);