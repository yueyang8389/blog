(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{335:function(t,e,a){"use strict";a.r(e);var s=a(3),r=Object(s.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"知识点总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#知识点总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 知识点总结")]),t._v(" "),a("h3",{attrs:{id:"深度优先与广度优先"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深度优先与广度优先","aria-hidden":"true"}},[t._v("#")]),t._v(" 深度优先与广度优先")]),t._v(" "),a("ol",[a("li",[t._v("深度优先：找到一个节点后，把它的后辈都找出来，最常用递归法。")]),t._v(" "),a("li",[t._v("广度优先：找到一个节点后，把他同级的兄弟节点都找出来放在前边，把孩子放到后边，最常用 while")])]),t._v(" "),a("h3",{attrs:{id:"es5与es6继承的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es5与es6继承的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" ES5与ES6继承的区别")]),t._v(" "),a("ol",[a("li",[t._v("ES5通过原型链实现继承")]),t._v(" "),a("li",[t._v("ES6 继承，是用extends关键字来实现。是在ES5原型链继承基础上包装的一层语法糖。")])]),t._v(" "),a("h3",{attrs:{id:"tcp三次握手四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手四次挥手","aria-hidden":"true"}},[t._v("#")]),t._v(" TCP三次握手四次挥手")]),t._v(" "),a("p",[t._v("三次握手来建立连接，四次挥手来断开连接。")]),t._v(" "),a("ul",[a("li",[t._v("三次握手")])]),t._v(" "),a("blockquote",[a("p",[t._v("三次握手之所以是三次是保证client和server均让对方知道自己的接收和发送能力没问题而保证的最小次数。")])]),t._v(" "),a("ol",[a("li",[t._v("第一次client => server 只能server判断出client具备发送能力")]),t._v(" "),a("li",[t._v("第二次 server => client client就可以判断出server具备发送和接受能力。此时client还需让server知道自己接收能力没问题于是就有了第三次")]),t._v(" "),a("li",[t._v("第三次 client => server 双方均保证了自己的接收和发送能力没有问题\n其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。")])]),t._v(" "),a("ul",[a("li",[t._v("四次挥手")])]),t._v(" "),a("blockquote",[a("p",[t._v("TCP是全双工信道，何为全双工就是客户端与服务端建立两条通道，通道1:客户端的输出连接服务端的输入；通道2:客户端的输入连接服务端的输出。两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：")])]),t._v(" "),a("ol",[a("li",[t._v("客户端：我要关闭输入通道了。")]),t._v(" "),a("li",[t._v("服务端：好的，你关闭吧，我这边也关闭这个通道。")]),t._v(" "),a("li",[t._v("服务端：我也要关闭输入通道了。\n4.客户端：好的你关闭吧，我也把这个通道关闭。")])]),t._v(" "),a("h3",{attrs:{id:"react中setstate什么时候是同步的，什么时候是异步的？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react中setstate什么时候是同步的，什么时候是异步的？","aria-hidden":"true"}},[t._v("#")]),t._v(" React中setState什么时候是同步的，什么时候是异步的？")]),t._v(" "),a("p",[t._v("在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。\n**原因：**在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为t rue，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。")])])},[],!1,null,null,null);e.default=r.exports}}]);